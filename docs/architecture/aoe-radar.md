# AOE 技术雷达

https://www.aoe.com/techradar



## 12 / 15 要素应用

[12 要素应用](https://12factor.net/de/)方法最初由 Heroku 开发，它提供了一套全面的构建云原生应用的最佳实践。此方法强调创建易于管理、可扩展且可跨不同环境移植的应用程序。[15要素模型](https://developer.ibm.com/articles/15-factor-applications/)扩展了此框架，以解决现代云原生开发中相关的其他问题。

### 12 要素应用程序的核心原则

1. **代码库**：维护一个在版本控制中跟踪的单一代码库，并进行多次部署。
2. **依赖关系**：明确声明并隔离依赖关系。
3. **配置**：在环境中存储配置。
4. **支持服务**：将支持服务视为附加资源。
5. **构建、发布、运行**：严格分开构建和运行阶段。
6. **进程**：将应用程序作为一个或多个无状态进程执行。
7. **端口绑定**：通过端口绑定导出服务。
8. **并发**：通过进程模型进行扩展。
9. **可处理性**：通过快速启动和正常关闭最大程度地提高稳健性。
10. **开发/生产奇偶校验**：尽可能保持开发、准备和生产相似。
11. **日志**：将日志视为事件流。
12. **管理流程**：将管理/管理任务作为一次性流程运行。

### 扩展到 15 个因素

15 因素模型在原有原则的基础上增加了：

1. **API First**：首先设计 API 以确保互操作性和面向未来性。
2. **遥测**：实施强大的遥测以进行监控和诊断。
3. **身份验证和授权**：采用强大的集中式身份验证和授权机制。

## 零信任

零信任是一种安全模型，在已知网络内不存在任何信任。

零信任机制无需对信任级别做出任何假设，默认情况下所有内容均被视为不受信任。身份验证和授权会持续进行，而不仅仅是一次。

Google 的 BeyondCorp 等框架就是基于该模式构建的。

### 动机和历史

传统安全范式通常保护特定的网络边界，例如公司内部网。

一旦某人“进入”公司网络（例如，在公司网络内工作或通过 VPN 连接到公司网络），他们通常被视为值得信任。

然而，随着云技术和微服务的兴起，以及人们在不同地点工作的事实，这种安全模型已不够用。网络边界在不断发展和扩大。

这对之前严重依赖网络段的身份验证主体提出了挑战。

### 零信任原则

零信任假设默认情况下不信任任何用户、服务或设备，无论其位置或网络如何。它需要持续验证身份、严格控制访问并持续监控网络活动。

**基本原则：**

- 最小权限
- 假设违反
- 强身份验证
- 明确验证

它涉及很多**领域和方面**，包括：

- 身份和身份意识
- 设备和设备身份验证
- 网络和防火墙
- 应用程序安全（安全设计、安全架构）
- 基础设施安全
- 安全数据处理
- 组织与文化
- 安全开发和交付
- 安全监控和自动化

### 实现

2009 年，谷歌实施了零信任架构（[BeyondCorp）](https://cloud.google.com/beyondcorp)，该架构利用 OAuth 和 OpenID 标准实现 Authn 和 Authz，影响了现代零信任架构的发展。

典型的实现涉及使用 IAM 和 SSO 的标准和工具，例如[Keycloak](https://www.aoe.com/techradar/tools/keycloak/)。

### 概括

虽然网络段和 VPN 连接在特定领域可能仍然相关，但 AOE 正在所有解决方案、组件和服务中越来越多地实施零信任方法。

我们目前正在采用零信任的最佳实践，它与 BeyondCorp 框架相一致并利用 OAuth 和 OpenID Connect 标准。

## 图表即代码

使用代码将概念和软件架构记录为图表比更繁重的解决方案具有显著的优势。将文档和图表视为代码并将其签入版本控制可提高透明度、协作和生产力。图表的文本表示易于编写和阅读，使用相关工具将图形表示生成为 SVG 或 PNG 图像也很简单。

我们广泛使用[PlantUML](https://www.aoe.com/techradar/tools/plant-uml/)与[Asciidoc](https://www.aoe.com/techradar/tools/asciidoc/)和[AsciiDoctor Diagram](https://asciidoctor.org/docs/asciidoctor-diagram/)等工具，在我们的文档中包含和内联 PlantUML 图表。后者允许使用各种其他图表格式，可以轻松混合和匹配。

其他值得一提的工具包括：

- [Mermaid](https://mermaid.js.org/)是一个基于 JavaScript 的图表工具，许多常用工具（例如 GitHub、GitLab、Gitea、Notion 等）原生支持它。
- [D2](https://d2lang.com/)是一种注重可读性的图表脚本语言，它提供了 CLI 和 Go 库以通过编程方式创建图表。
- [Structurizr](https://structurizr.com/)，它带有自己的 DSL，用于基于[C4 模型](https://c4model.com/)创建软件架构模型，以及用于导出为 PlantUML、Mermaid、D2 等格式的 CLI。

## Loki


在获得非常积极的体验后，我们决定用 Loki 替换我们的ELK，主要原因如下：

- Loki 的存储要求比 Elasticsearch 的成本效益明显更高。
- PromQL 类查询语言为 Prometheus 用户所熟悉，它使已经使用 Prometheus 进行监控的 DevOps 和 SRE 团队可以更轻松地处理日志。
- Loki 与 Kubernetes 的原生集成简化了设置和配置过程。
- 与 ELK 相比，Loki 通常需要较少的维护和开销。

使用Elasticsearch之类的系统归档索引日志数据可能非常昂贵，而将其归档为简单的文本文件又很难查询。Loki通过向每条日志行添加基于Kubernetes标签的参考数据库（类似于Prometheus）解决了这个问题，但将日志数据存储在简单的 blob 存储（如 AWS S3）中。这允许用户通过预定义的标签查询数据，并保持较低的索引成本。

另一个好处是，Loki 没有用于改变日志数据的端点，从而使数据对于可能受到损害的系统来说是不可变的。

## 架构决策记录

架构决策记录

ADR 是团队做出的重要架构决策的轻量级文档。如果没有架构和架构决策的文档，新团队成员只能做两件事：

- 要么（盲目地）接受他们发现和看到的东西，要么
- （盲目地）改变事物

毋庸置疑，这两种选择都是不正确的。

因此，我们建议记录重要的架构决策。我们使用一个简单的工具，例如https://github.com/npryce/adr-tools并将它们存储在版本控制中。在拥有许多团队的大型项目中，我们还会定期建立“架构委员会/COI”，并定期开会。通常，架构决策是在这样的会议上做出的。

本文档的主要目的是：

- 向新团队成员告知之前的架构决策及其目的和背景
- 通知整个团队（包括所有缺席的人）
- 创建可用于记住事物的文档（例如约定、模式等）

## API 优先设计方法

API 优先设计方法将 API 设计置于实施之初，不受任何限制，例如不受当前 IT 基础设施或实施本身的限制。其理念是设计 API，使其能够最好地满足其用途，并使消费者能够高效工作。

这种方法有几个优点。例如，它可以帮助避免反映应用程序的内部结构或任何内部约束。此外，由于一致性是最重要的设计方面之一，因此可以预先定义安全行为、URL 方案和 API 密钥等功能。它还有助于加快并行实施。使用 API 的团队可以在 API 设计后直接开始工作，因为它很容易被模拟。

有多种工具可用于对 API 进行建模，但在 AOE 我们主要使用[RAML](https://www.aoe.com/techradar/languages-and-frameworks/raml/)，因为它提供了一套丰富的工具用于生成文档、模拟等。例如，对于模拟，我们使用[WireMock 。](https://www.aoe.com/techradar/tools/wiremock/)

与“API-First”方法相关的是“Headless”方法，其中现有应用程序（有或没有现有 API）用作单独前端的后端。我们成功地将这种方法用于基于 Magento 的电子商务平台。这允许封装该应用程序的核心功能，同时将其集成到更大的组件环境中，使用其 API 作为组件之间交互的统一方式。将核心逻辑与其表示层分离允许独立为各个部分选择最佳技术堆栈。

欲进一步了解，请参阅：

- [理解 API 优先设计](https://www.programmableweb.com/api-university/understanding-api-first-design)
- [制定 API 策略时，请将设计放在首位](http://www.techradar.com/news/software/applications/when-crafting-your-api-strategy-put-design-first-1262043?src=rss&attr=all)

## 应用程序性能管理

应用程序性能管理 (APM) 能够在性能问题影响用户或业务之前预测和预防这些问题。APM 解决方案可帮助组织确保应用程序满足性能、可用性和用户体验期望。这可以通过测量应用程序性能、提供对性能问题的可见性、在出现性能问题时提醒开发人员和管理员以及允许分析改进与之前状态相比的可靠性来实现。在过去几年中，APM 解决方案已从应用程序性能监控工具发展为功能更全面的系统，其中包括可观察性、性能数据收集和分析，这与分布式云原生应用程序更为契合。

我们在 APM 方面的经验与应用程序的仪表化有关。这包括公开指标、跟踪和与[New Relic](https://newrelic.com/)等外部服务的集成。我们决定采用这种方法，因为它简单易用，并且在日常分析和优化我们的软件时表现出色。

## 无可指责的事后分析

> 失败与创新是密不可分的孪生子。
>
> —杰夫·贝佐斯

无责事后分析提供了一种处理在开发和运行复杂软件解决方案时不可避免地发生的故障的概念。在任何重大事故或中断发生后，团队都会聚集在一起，深入分析发生了什么，并采取哪些措施来降低将来发生类似问题的风险。

基于信任和假设，即所有参与人员都善意地根据手头的信息尽力做好工作，无过失事后分析提供了一个机会，可以不断提高软件和基础设施的质量以及处理紧急情况的流程。我们认为这是一项基本原则，使我们的员工能够毫无顾虑地解决缺陷，并降低事件被隐瞒的可能性。

事后分析文件通常包括导致事件发生的时间表和采取的补救措施，以及为增强我们服务的弹性和稳定性而采取的未来行动和经验教训。

在 AOE，我们优先在每次用户可见事件发生后召开无责事后分析会议。

## 客户端错误日志

越来越多的业务逻辑是在客户端使用各种 Web 和应用技术完成的。我们如何知道生产环境中一切是否正常？我们可以轻松地在服务器日志中跟踪后端异常，但用户浏览器或移动应用中的客户端错误怎么办？

通过客户端错误日志记录，我们可以将错误发送到中央服务器，以便立即查看问题所在。通过这种方法，可以快速发现并解决错误，以免影响更多用户。

在 AOE，我们使用开源解决方案[Sentry](https://sentry.io/welcome/) .io。它可以处理多个项目和团队，并能与 Mattermost/Slack 和问题跟踪系统等其他服务很好地集成。

## 基于容器的构建

在隔离的容器中运行构建可保持构建服务器的整洁。它甚至允许您使用框架或编程语言的多个版本来运行它们。您不需要额外的机器，就像同时使用 PHP5 或 PHP7 运行构建或运行一些旧版构建一样。

请注意，您需要为依赖项考虑某种缓存机制，以避免在每次构建时下载它们，这会导致较长的构建时间。

在 AOE，我们目前开始使用这种方法来构建服务，如果您的构建具有特殊依赖关系，这种方法尤其有用。此外，可以使用 GitLab 作为构建工具，或将 Docker 与新的 Jenkins 管道一起使用。对于缓存，我们正在评估 minio 作为缓存服务器。我们注意到，我们的构建运行得非常迅速和可靠。此外，构建的复杂性也降低了，因为我们不需要任何解决方法，而解决方法是将所有内容都安装在一台构建服务器上。

## 常规提交

常规提交规范是提交消息之上的轻量级约定。它提供了一小组规则，用于编写提交消息并因此创建明确的提交历史记录。该约定与[SemVer](https://www.aoe.com/techradar/methods-and-patterns/semver2/)相吻合，通过描述提交消息中所做的功能、修复和重大更改。该规范仅包含 16 个易于遵循的项目。预定义的结构使团队中的每个人都能更好地了解提交消息与什么相关以及更改与代码的哪部分有关。使用这些规范的一些好处包括：能够自动生成更改日志，能够确定语义版本升级（基于提交的类型）并能够向队友和利益相关者传达更改的性质。

我们在团队中使用 git 模板的帮助来进行常规提交。该模板包含规范中所需元素的指南，以及一些有关项目特定项目的信息，这些项目也应是提交的一部分，例如票号。

我们的团队广泛使用传统提交，因此我们正在改变它以采用它。使用遵循传统[提交规范](https://www.conventionalcommits.org/en/v1.0.0/)的提交消息有助于我们轻松处理软件版本中所做的更改。它还有助于减少新团队成员对提交消息要求的困惑。

[Semanticore](https://github.com/AOEpeople/semanticore)发布机器人是我们发布的一个工具，它利用常规提交来维护我们软件的发布说明并建议即将发布的正确版本。

## 通过消息传递解耦

在[微服务](https://www.aoe.com/techradar/methods-and-patterns/microservices/)中，我们已经介绍了现代架构从大型单片应用程序转向分布式软件套件的趋势。将我们的软件和基础设施拆分成更小的部分的结果是这些部分需要相互通信。这可以通过直接通信或基于消息的异步通信来实现。

同步通信可使整个系统的“实时”响应时间更加可预测，而异步通信则可显著提高系统的弹性和稳定性，并允许使用其他集成和扩展模式。然而，它通常会带来额外的复杂性。

大多数 IaaS 云提供商都提供消息传递服务，例如[AWS SQS](https://aws.amazon.com/sqs/)，这些服务提供了通过消息传递来解耦我们的基础架构的可能性。此外，我们在应用程序中使用[RabbitMQ](https://www.aoe.com/techradar/tools/rabbitmq/)作为消息传递和代理解决方案。将消息传递和消息传递模式用作集成策略的决定可以作为[战略设计](https://www.aoe.com/techradar/methods-and-patterns/strategic-domain-driven-design/)考虑的一部分。



近年来，消息传递系统变得更加强大、可扩展且更易于与现有应用程序集成。这增加了消息传递在现代软件架构中的重要性，使其成为解耦组件和确保分布式系统弹性和稳定性的重要策略：

- **事件流：** [Apache Kafka](https://www.aoe.com/techradar/tools/kafka/)等平台已经取得了长足的发展，能够处理海量数据流，并且具有增强的可靠性和集成能力。
- **无服务器消息传递：无**[服务器计算](https://www.aoe.com/techradar/methods-and-patterns/serverless/)的兴起简化了可扩展、事件驱动架构的创建，使开发人员无需承担管理基础设施的开销即可构建复杂的工作流和事件处理管道。
- **高级可观察性**：改进的消息系统监控和管理工具现在可以提供有关消息流和系统性能的详细见解，从而能够更快地诊断和解决问题。

## 依赖项更新扫描

自动依赖项扫描有助于消除定期检查版本更新的手动任务。我们的团队正在使用开源机器人[Renovate](https://github.com/renovatebot/renovate)和[Scala Steward](https://github.com/fthomas/scala-steward)，这两个机器人都作为我们内部基础设施中的计划 GitLab 作业运行。这些机器人会定期针对我们的项目创建包含依赖项版本更新的合并请求。

实现自动化有几个好处：

- 重要的依赖项更新在发布后不久即可获得（例如针对安全问题）
- 合并请求中引用了变更日志，因此可以轻松查看更新是否相关
- 自动触发的管道正在运行我们的测试套件，如果管道成功，我们可以高度确信版本更新不会中断
- 定期的小更新比一次性对多个库进行批量更新更容易维护，从而降低了引入兼容性破坏性更改的风险

自动合并请求使我们能够以更少的努力专注于审查、测试和确定依赖版本更新的优先级。



当自动依赖更新工具很好地集成到构建工作流中时，它将持续提供巨大的生产力提升。

尽管如此，这也并非毫无警告。虽然理论上很棒，但不断更新可能会很快导致合并请求的轰炸。所选工具的可靠性和集成性至关重要。否则，这可能会让团队不堪重负。作为替代方案，我们在禁用自动合并请求并在想要处理更新时手动触发作业方面也有很好的经验。

## 设计系统

设计系统是可重复使用的设计组件、指南和标准的集合，为整个产品或整个品牌创建一致的用户体验奠定基础。

它有助于创建统一的视觉语言，改善设计和开发团队之间的协作，并简化设计和开发流程。

设计系统还提高了产品设计的可维护性，使团队更容易随着时间的推移进行更新和添加新功能。

我们正在与我们的一位客户密切合作，实施一个设计系统。

我们为此使用的工具是[zeroheight](https://zeroheight.com/)作为文档中心、 [Style Dictionary](https://amzn.github.io/style-dictionary)用于生成令牌、 [Storybook](https://storybook.js.org/)用于记录组件和[Figma](https://www.figma.com/)用于设计。

## DevOps 实践

DevOps 这个词已经存在好几年了。我们认为 DevOps 是一种哲学和文化，以及相关的实践和工具 - 所有这些都是为了使 (IT) 运营更接近开发。

Jez Humble 这样描述 DevOps 运动：“一个跨职能的实践社区，致力于研究大规模构建、发展和运行快速变化、安全、有弹性的系统”。

随着软件项目规模的扩大和敏捷开发的效果，以敏捷方式交付运营和基础设施的需求也越来越大。

我们一直采用以下做法并取得成功：

**跨职能团队“你构建，你运行”**

在过去的一年里，我们已经从一个更加集中或独立的 IT 和运营服务团队转变为跨职能团队，其中基础设施专家与开发团队一起工作（管理员加入项目团队）。

此外，我们已将大型项目改为跨职能团队和“你构建，你运行”的方法。我们已经看到，这会带来以下积极影响：

- 软件应用程序架构需要一定的基础设施，反之亦然。一个团队拥有所有的专业知识可以做出更多重大决策和实施。此外，解决问题的根本原因也更有效。
- 整个团队内部的轮换操作和事件管理使每个人都更密切地关注其软件的日常运行。这导致团队对整个平台的责任和承诺的共享和改善。此外，这让开发人员与客户保持联系 - 这也是一个重要的反馈循环。
- 基础设施的灵活性增强：基础设施的实施和调整速度更快，并且可以与平台的持续敏捷开发一起进行。
- 开发人员在构建应用程序时也会明确考虑操作问题 - 因为他们负责操作。例如，日志记录概念、监控方面和弹性模式现在明确地不断优化并改进得更快。这种方法的重要推动因素是项目的规模和可用预算（并非每个项目都允许拥有持续的跨职能团队来执行持续的开发和运营）。此外，这需要团队具有一定程度的独立性。

与以往一样，我们正在建立“利益共同体”，以改善和促进不同团队之间的知识转移。

**增加相关工具**

DevOps 实践的另一个重要方面和推动因素是某些工具和方法的增加 - 其中一些也出现在技术雷达中。例如：Puppet 环境；Docker；云服务、Terraform、Consul 等。

**开发设置 = 生产设置，[基础设施即代码](https://www.aoe.com/techradar/methods-and-patterns/infrastructure-as-code/)**

将开发基础设施设置保持在接近生产状态也是一种常见的做法，也是“基础设施即代码”方法的直接结果。以类似于应用程序的方式处理基础设施以及所需的更改和创新非常重要；您可以在此处阅读更多相关信息：基础设施即代码

我们鼓励所有团队在团队中采用 devops 实践，并注意团队中不同专家之间的真正合作，并且不存在看不见的墙。

## GraphQL

[GraphQL](https://graphql.org/)是一种用于 API 的查询语言，也是使用您为数据定义的类型系统执行查询的服务器端运行时。它不依赖于任何特定的数据库或存储引擎，而是由您现有的代码和数据支持。

GraphQL 由 Facebook 于 2010 年左右开发，并于 2015 年发布。它解决的主要挑战是改善高动态 Web 应用程序上浏览器和服务器之间的通信。

主要优势包括：

- 模式和模式验证以及有用的类型系统
- 客户端（浏览器）控制应发送哪些数据（数据减少）
- 只需一个请求即可获取“所有”所需数据

[可以使用Apollo 客户端框架](https://www.aoe.com/techradar/tools/apollo-client/)实现客户端集成，该框架可轻松集成到基于[React.js](https://www.aoe.com/techradar/languages-and-frameworks/react/)的前端。

Flamingo 框架[提供对 GraphQL 的支持](https://docs.flamingo.me/3. Flamingo Modules/graphql.html) ，而 Flamingo Commerce 为电子商务提供了功能齐全的 GraphQL API： [Commerce 的 GraphQL 控制台示例](https://demoshop.flamingo.me/en/graphql-console)。



对于基于[Spring Boot 的](https://spring.io/projects/spring-boot/)后端，[DGS](https://netflix.github.io/dgs/)提供了一个很好的框架，其特点是：

- 基于注释的 Spring 编程模型
- 用于将查询测试编写为单元测试的测试框架
- [Gradle](https://gradle.org/)代码生成插件，用于从 Java 或 Kotlin 中的 GraphQL 模式创建类型

## 微服务

微服务作为一种架构风格最近非常流行。在 AOE，越来越多的团队在现有应用程序架构中添加微服务或使用微服务设计应用程序。

我们还喜欢使用“自包含系统”这个术语，而不是微服务。

我们看到的好处是：

- 与以单片方法添加功能相比，可以更好地处理复杂性
- 能够使用最适合服务目的的语言和框架
- 实现大团队或多团队项目中更好的并行工作
- 灵活地部署生产变更 - 只需部署变更的服务

相关模式是[战略领域驱动设计](https://www.aoe.com/techradar/methods-and-patterns/strategic-domain-driven-design/)，这是一种根据有用的有界上下文明智地削减架构并决定服务之间相关通信和“转换”的方法。如果您正在为您的微服务架构寻找一个小型可视化工具，您可能会发现[vistecture](https://github.com/AOEpeople/vistecture/)很有用。

当将应用程序设计为一套微服务时，[弹性思维](https://www.aoe.com/techradar/methods-and-patterns/resilience-thinking)尤为重要。



我们仍然相信微服务概念及其相关模式和最佳实践。然而，值得一提的是，在弹性思维和微服务之间的部署相关依赖关系方面，我们必须吸取一些教训。

我们认为，基于微服务的应用程序比单体应用程序更强大。由于将整体复杂性拆分为多个服务，新员工或团队成员可以在几天或几周内开始高效工作。

为了正确使用微服务并从中受益，还需要做很多事情。以下微服务的“需求金字塔”显示了这一点： ![微服务需求金字塔](https://www.aoe.com/techradar/images/microservices-pyramid.png)

## 群体编程

在AOE进行结对[工作](https://www.aoe.com/techradar/methods-and-patterns/pair-working/)实践已有数年之久后，我们在 COVID-19 疫情期间转向远程工作，开始广泛探索[远程群体编程。](https://www.remotemobprogramming.org/)

群体编程将驾驶员/导航员模式提升到了另一个层次，因为它将一组导航员引入了游戏。由于整个开发团队专注于一个主题，因此在每次会议中都会产生许多共同的理解和共享的知识，因为每个人都参与了开发过程。结果是代码审查的争议减少了（甚至可能完全被省略），并且团队编码风格演变为有利于个人解决问题的方式。

在实践中，我们发现基于 Git 的[mob](https://github.com/remotemobprogramming/mob)是一种易于使用的远程 mob 编程工具。它提供了一种快速而简单的方法来启动 mob 会话、将更改移交给下一个人并提交结果。

## 固定外部依赖项

许多应用程序都依赖于其他模块或组件。对于如何以及何时解决这些依赖关系，我们采用了不同的方法，并一致同意使用一种我们称之为“固定（外部）依赖关系”的方法。

这对于脚本语言尤其重要，其中依赖管理引用代码而不是不可变的预构建二进制文件 - 因此可以动态解决完整的瞬态依赖关系。

大多数这些包或依赖项管理解决方案都支持两种工件：

- 语义依赖定义。这定义了所需依赖项的兼容版本。（Composer：composer.json / npm：package.json）
- 一个锁定文件，定义依赖项和临时依赖项（依赖项的依赖项）的确切修订版本。这是在运行该工具后创建的。（Composer：composer.lock / npm：npm-shrinkwrap.json / yarn：yarn.lock）。

我们建议如下：

- 将依赖项定义和锁定文件保留在版本控制中。这可确保链接的依赖项也被锁定，并且您可以在版本控制提交历史记录中看到该文件的更改。这有助于发现可能与外部模块或临时依赖项中的意外更新有关的问题或错误。
- 构建步骤：应用程序构建步骤应该使用固定版本（在锁文件的帮助下）来确保使用依赖包的相同修订版本。
- 还建议使用本地或中央缓存来检索包。（例如 [artifactory作为composer和npm缓存](https://www.aoe.com/techradar/platforms-and-aoe-services/artifactory/)）

为了更新依赖项，请在团队中定义一个流程。这可以在开发系统上完成，也可以在单独的自动化 CI 作业中完成 - 两者都会导致应用程序 VCS 中的依赖项定义更新。

## 管道即代码

持续集成和交付是 AOE 开发和部署流程中的关键部分。使用 Jenkins 多年后，如何构建、测试和部署应用程序的“说明”分散在许多自定义脚本中，并且管道通常通过手动维护 Jenkins 作业来维护。很快，我们意识到我们需要一种更原生的方式来用代码表达完整的 CI/CD 管道流程并在版本控制中进行管理。

作为每个项目的重要组成部分，管道配置应该作为代码进行管理并自动推出 - 这也使我们能够使用适用于应用程序代码的相同标准来管理管道本身。

当一些团队开始使用 Jenkins 的[JobDSL 插件时，](https://wiki.jenkins-ci.org/display/JENKINS/Job+DSL+Plugin)其他团队则探索了新的[Jenkins Pipeline](https://jenkins.io/doc/book/pipeline/) - 无论哪种方式，构建工件都应该发布到工件存储库，例如[Artifactory](https://www.aoe.com/techradar/platforms-and-aoe-services/artifactory/)。



在过去的几年里，许多工具已经发展起来，尤其是[Gitlab CI](https://docs.gitlab.com/ee/ci/)、 [GitHub Actions](https://github.com/features/actions)和[AWS CodeDeploy](https://aws.amazon.com/de/codedeploy/) 已经成熟或变得可用并被许多团队广泛使用。

持续集成和交付是每个项目的重要组成部分。以代码形式维护的管道现在可以像软件的大多数其他部分一样进行处理。管道配置可以在组织内各个团队之间共享配置之前通过 lint 检查或测试套件运行。

使用[基于容器的构建](https://www.aoe.com/techradar/methods-and-patterns/container-based-builds/)现在也是事实上的标准。结合这两种技术可以在易于重现的环境中运行隔离构建，因此团队可以快速获得对每个更改的反馈。

## 端口和适配器

端口和适配器是一种软件设计架构或分层方法。与其他分层方法一样，它将不同的关注点分离到不同的层中，其中依赖关系只允许从外部到内部。

我们成功地将“端口和适配器”用于（较大的）应用程序，这些应用程序包含某些业务逻辑和/或提供多种访问服务的方式。我们经常将该方法与领域驱动设计结合使用。与其他分层模式（例如分层架构）相比，它允许您拥有真正的无技术核心（领域）模型。为什么？因为，通过“辅助端口”（=接口）的概念，它反转了控制并允许外层提供适配器（=定义接口的实现）。它还定义了有关将应用程序的逻辑放在哪里的明确界限。

您可以在著名博客文章（如[《清洁架构》](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)或[《六边形架构》）中了解有关其细节和起源的更多内容](http://alistair.cockburn.us/Hexagonal+architecture)

简而言之，我们通常对此类应用程序进行分层的方式如下：

- 领域：
  - 是内层，包含无技术领域模型
  - 通常使用领域驱动设计的构建块
  - 它定义了主要端口和次要端口。（例如，次要端口位于需要在基础设施层中实现的“接口”中。）
- 应用：
  - 包含围绕应用程序需求中的用例开发的应用程序的 API 和服务。
  - 这些用例协调了域内数据流
- 接口：
  - 包含将数据从最方便用例的格式（例如在应用层）转换为外部机构/访问所需的格式所需的一切
  - 例如（Web）用于处理表单的控制器/DTO等。
- 基础设施：
  - 所有（技术）细节都存在于此层。（数据库和持久性是一个细节，通信格式和与外部服务的映射也是一个细节，等等。）
  - 在此层中，您通常具有已在下面的层中定义的辅助端口的适配器。（例如，来自域层的存储库接口的实现）

这些层属于应用程序内部的每个有界上下文（模块）。

您是否在为您的关键应用程序寻找一种潜在的永恒架构？尝试在核心层实现强大的无技术域模型，并使用端口和适配器对应用程序进行分层。

## 韧性思维

弹性是应用程序或服务抵御不同错误情况的能力。特别是对于分布式系统（不同服务之间会发生大量通信），明确考虑实现弹性非常重要。

有很多不同的弹性模式，这也是整个软件设计的问题。使用的典型模式和方法包括：

- 不要隐藏应用程序中的 API 调用或任何其他外部通信（例如使用不必要的抽象） - 而是明确说明外部通信的发生 - 例如通过使用 Facade 模式。一方面，这可以清楚地表明潜在的缓慢且容易出错的通信将会发生，并且使实现错误处理变得更加容易。
- 明确检测错误：检查响应消息格式并为外部通信配置适当的超时
- 以智能方式处理错误：向客户显示一条友好的错误消息，或者更好的是，优雅地降低功能 - 例如通过显示一些后备文本
- 在有用的地方使用基于消息的通信（[通过消息传递解耦](https://www.aoe.com/techradar/methods-and-patterns/decoupling-via-messaging/)）
- 使用断路器隔离错误并允许系统恢复
- 在您的战略架构中使用短激活路径 - 这样您的服务之间只需要进行最少的通信即可满足某些功能或业务请求

“接受错误”应该是我们的心态，因为错误是否出现不是问题，而只是时间问题。

## 语义版本控制 2.0

[语义版本控制 2.0](https://semver.org/spec/v2.0.0.html)是一种指定软件版本的方案。作为事实上的标准，它被广泛应用于软件开发的所有领域。它提供了一种在开发软件的整个生命周期内传达变更的清晰方法。

特别是在许多组件相互依赖的大型项目中，跨团队进行明确的沟通非常重要。

## 设置注入

在将应用程序部署到某个环境时，通常需要针对该特定环境配置应用程序。典型设置包括域名、数据库凭据和其他依赖服务（如缓存后端、队列或会话存储）的位置。

这些设置不应随构建包一起提供。相反，环境（此构建将部署到其中）应该将这些值公开给应用程序。“注入”这些值的常见方法是将它们作为环境变量提供或为应用程序动态创建配置文件。您无需特殊工具即可实现此模式 - 但此设置注入概念也适用于[Consul](https://www.aoe.com/techradar/tools/consul/)、[kubernetes](https://www.aoe.com/techradar/platforms-and-aoe-services/kubernetes/)（带有 configMaps 和 secrets）或[YAD](https://github.com/AOEpeople/YAD)等工具。

通过这种方式，构建包可以独立于其部署到的环境 - 从而更容易遵循“一次构建，经常部署”的 CI/CD 原则。

## 风格指南驱动开发

样式指南驱动开发的目标是独立开发应用程序用户界面，并在模式库中重复使用。
过去，前端是基于以页面为中心的 Photoshop 文件开发的，这使得事后很难更改。使用样式指南驱动开发，您可以构建较小的元素，这些元素可在所有前端中重复使用。

您可以在生产阶段的早期开始开发 UI 组件（HTML/CSS/JavaScript），而无需等待现成的开发系统。
设计师和测试人员可以尽早提供反馈，您可以与外部团队共享文档和代码。

在 AOE，我们使用[Hologram](https://trulia.github.io/hologram/)从源文件直接构建动态文档。每当需要新的 UI 元素时，开发人员就会开始在样式指南中构建它——而不是在实际的应用程序代码中。通过编写新组件的代码，可以立即为其创建文档。任何其他开发人员都可以轻松查看哪些元素存在以及如何在代码中使用它。

## 团队起始页

团队起始页可帮助（新）成员熟悉情况。它通常显示所有团队成员及其角色和联系数据，以及指向必要工具的链接集合，例如

- 项目环境（暂存、生产……）
- 项目开发设置
- 版本控制系统
- 代码审查工具
- 团队规则
- Slack 邀请
- ...

简单的事情，大家都应该知道。

在 AOE，我们希望在我们的 wiki 中为每个团队提供一个团队开始页。

## 复杂性管理

我们的世界越来越复杂——我们的社会和经济体系正在快速发展——我们必须不断应对意外和不确定性。在 IT 组织中尤其如此，这些组织协作和跨职能地开展创新、“数字化战略”或“转型项目”。

如果某事物的所有元素无法同时关联，则该事物就是复杂的。没有明确的因果关系。决策过程无法很好地组织起来。

但当然这不应该被当作借口。这种认识可以激励我们找到更好的方法来处理它。一起想出更好的新想法，做出正确的决定并从中吸取教训。

复杂性管理能力描述的是处理复杂性的能力。观察和分析情况的维度越多，差异化程度越高，速度越快，复杂性管理就越好。C2M[模型](https://www.carl-auer.de/magazin/systemzeit/komplexitatsmanagement-modell-stufen-formen)

IT 计划和项目的复杂性来自于产品如何被用户和市场采用的不确定性、技术要素几乎无穷无尽的选择、团队和组织结构以及既定的协作和沟通等。

敏捷方法和其他最佳实践是从这些挑战中发展起来的 - 并且现在已被广泛采用 - 但是如果没有适当的反思和复杂性管理，它们也可能导致功能失调的沟通模式。

由于我们正在协作解决问题，因此我们还需要处理通信系统（社会系统）的复杂性：

- 我们经常看到大型和历史悠久的组织在转型计划中遇到困难。
- 我们看到，随着时间的推移，团队中出现了功能失调的模式。
- 我们看到一些团队没有建立清晰的沟通，也没有解决重要的冲突。
- 我们看到团队的争论都是单一的，并且浪费时间和精力进行无意义的辩论。
- 我们看到组织充满了内部导向和活动——而他们正在失去与外部客户和市场的联系。

了解沟通系统如何运作，以及存在哪些有效沟通（以及协作）的条件，有助于更好地解决此类情况。它还有助于理解我们如何利用冲突来发挥创造力（创造新的观点和想法）。

这包括我们始终可以互相学习的意识！

这就是我们看到具有适当系统理论背景的系统观点在组织发展领域出现的原因。我们相信，正确学习这些观点和了解复杂性管理能力可以帮助组织形成功能协作。这种学习有助于更加自觉地反映系统和自我——这可能是产生更多影响和学习的良好条件。这也有助于组织不盲目追随下一个模型、敏捷“炒作”或顾问承诺。

更多相关内容：[系统沟通](https://www.carl-auer.de/magazin/systemzeit/communication-reorganization-of-undetermined)

## DevOps 的 DORA 指标

软件开发组织的主要目标是提高软件交付和运营的性能。

关于如何“正确实施 DevOps”，存在许多最佳实践和不同意见。我们了解到，IT 组织和软件交付是复杂的问题，这意味着大多数时候没有“简单”的答案。相反，在上下文框架内持续改进是一个关键要素。

为了引入更多的客观性和可验证性度量，我们喜欢使用“DevOps 现状”和“DORA”建议的四个关键指标。这四个关键指标是：

**评估速度：**

- 部署频率（团队成功部署到生产的频率，例如每日、每周、每月、每年）
- 变更前置时间（将提交部署到生产所需的平均时间）

**评估稳定性：**

- 恢复服务的时间（对于故障，导致故障的部署与修复之间的平均时间）
- 变更失败率（每次部署的失败次数）

### 关于 DORA

DevOps 研究与评估 (DORA) 是同类研究中规模最大、持续时间最长的研究项目，旨在了解推动软件交付和运营绩效的能力。他们的报告“DevOps 现状”定期提供有关高绩效 IT 组织的见解、观察和见解。

### 附加信息

- [DORA 网站](https://dora.dev/)
- [DORA 的旅程：一次探索](https://medium.com/@jezhumble/doras-journey-an-exploration-4c6bfc41e667)
- [DORA GitHub 存储库](https://github.com/dora-team/fourkeys)

## 单体优先

单体[优先](https://martinfowler.com/bliki/MonolithFirst.html)方法主张以精心模块化的单体架构开始新项目。它通过确保单体架构良好地构建为离散的封装模块，平衡了单体系统的简单性与微服务的灵活性。

战略性单体架构的概念源于这样一种理念：从单体架构入手对许多组织都大有裨益，尤其是在处理新项目或小型项目时。单体架构由于其内聚性而更易于开发、测试和部署。正如 Martin Fowler 指出的那样，许多成功的软件系统都是从单体架构开始的，只有在规模或复杂性需要时才过渡到微服务。这种方法使团队能够管理复杂性和可维护性，同时为未来过渡到微服务奠定基础。通过模块化单体架构，开发人员可以在代码库中创建清晰的边界，从而更轻松地根据需要提取单个服务。

### 好处

- **面向未来的架构**：整体式架构中的模块化设计允许随着需求的发展或业务的增长，将系统的各个部分轻松提取到单个微服务中。这种方法确保架构可以适应不断变化的需求，而无需进行大量重构。
- **操作简单**：从单体架构开始，通过将所有模块保留在单个可部署单元中，简化了部署和管理。这降低了与分布式系统相关的复杂性和开销，例如处理服务间通信、分布式数据管理和全面监控。
- **性能和延迟优势**：与微服务中的服务间通信相比，整体式架构中的进程内通信可降低延迟并提高性能。这可确保系统在扩展时保持响应速度和效率。
- **降低复杂性**：“整体优先”方法避免了分布式系统的初始挑战，使团队能够专注于构建强大的功能并在考虑过渡到微服务之前深入了解领域。

在 AOE，我们在启动绿地项目时努力遵循这种方法。我们的目标是在创建“尽可能小”和“尽可能大”的系统之间取得平衡，确保架构强大且可维护，能够根据业务需求进行扩展和发展。这提供了一条平衡的路径，将当前开发需求与长期架构目标相结合。

## 策略即代码

随着云基础设施和 DevOps 实践的兴起，传统的政策执行方法（例如手动审查和审计）已不再足够。通过使用代码来表达整个基础设施和应用程序堆栈的策略，自动合规性检查成为软件开发生命周期的自然组成部分，例如通过集成到项目的 CI/CD 管道中，甚至可以在发现关键问题时阻止配置更改或部署。

“策略即代码”的主要优势之一是能够在潜在问题变成风险之前将其捕获。例如，可以定义一个策略来确保所有 S3 存储桶都已加密，或者所有 EC2 实例都具有一组特定的标签。

有许多工具和框架可用于实现策略即代码。在 AOE，我们在撰写本文时主要依赖 [Checkov](https://www.checkov.io/)、[Kyverno](https://kyverno.io/)和[AWS Config](https://aws.amazon.com/config/) 。每种工具都提供了一种在代码中定义策略然后自动执行策略的方法。它们还提供对基础设施和应用程序配置的合规性状态的可见性。

通过将策略定义为代码，开发团队可以确保策略在所有环境中都是版本控制的、易于审核的、并且一致。

## 检索增强生成 (RAG)

[检索增强生成 (RAG)](https://blogs.nvidia.com/blog/what-is-retrieval-augmented-generation/)是一种通过结合外部信息检索来增强生成式 AI 模型的方法。RAG 结合了基于检索和基于生成的模型的优势，使 AI 能够通过在生成过程中访问和集成外部数据源来生成更准确、更符合上下文的响应。这种方法通常使用嵌入将文本转换为高维向量，并使用向量数据库根据相似性搜索有效地存储和检索这些向量。这显著提高了 AI 生成内容的质量和可靠性，使其在需要最新信息或特定领域知识的应用程序中特别有用。

### 好处

- **增强的上下文准确性**：通过整合外部数据，RAG 模型比传统的生成模型提供更准确、更具上下文相关的答案。
- **动态信息访问**：允许模型检索并使用查询时可用的最相关信息，确保最新的响应。
- **多功能应用**：适用于广泛的用例，从客户支持和虚拟助手到内容创建和研究，准确的信息至关重要。
- **可持续资源利用**：通过利用外部最新的数据集进行信息检索并将其与生成能力相结合，RAG 模型减少了对大量数据处理和计算能力的需求，从而降低能耗。
- **减少幻觉**：通过将响应建立在可验证的外部数据上，最大限度地减少人工智能生成合理但不正确信息的情况。

### 挑战

- **延迟**：实时检索和处理外部数据可能会引入延迟，与纯生成模型相比，可能会减慢响应时间。
- **依赖外部数据质量**：生成内容的准确性和相关性高度依赖于外部数据源的质量和可靠性。质量差或过时的数据会对结果产生负面影响。
- **安全和隐私**：访问外部数据源可能会使系统面临安全漏洞和隐私问题。缓解策略包括谨慎的数据访问管理和在检索过程中采取强有力的安全措施。
- **维护开销**：需要定期更新和维护检索系统和数据源以确保持续的准确性和相关性，这增加了运营负担。
- **偏见的可能性**：检索过程可能会引入外部数据中存在的偏见，这些偏见会传播到生成的内容中，从而影响输出的公平性和客观性。

在 AOE，我们正在评估[LangChain](https://www.aoe.com/techradar/languages-and-frameworks/langchain/)作为实现聊天机器人的框架，该框架允许用户更好地与现有知识进行交互，并确保他们提供准确、上下文相关且可靠的信息。

## 共担责任模式

自从引入“平台工程团队”来构建、维护和运营我们的 Kubernetes 集群和其他相关平台服务以来，问题就出现了，谁负责各种任务，例如保持正常运行、应用关键安全修复、总体更新软件、关注账单等等。我们并不是在这里提出如何分担责任的解决方案，而是希望提高大家的意识，让大家聚在一起，正式讨论所有责任，并将它们写下来，类似于（并可能扩展）AWS 的[共享责任模型](https://aws.amazon.com/compliance/shared-responsibility-model/)。一些主题是 24/7 随叫随到的支持、中断的部署管道和漏洞扫描。

## HAL/HATEOAS

超媒体作为应用程序状态的引擎，简称 HATEOAS，是一种有助于组织 RESTful API 中的依赖项和资源的模式。HATEOAS 的基本思想是 API 使用者不必知道资源的依赖项是如何连接的以及如何获取它们。消费者只需熟悉超媒体的基础知识即可。

假设我们有一个银行账户和一个向该账户存款的操作。您需要知道的是，账户资源有一个存款操作。然后可以从具有相应关系的链接属性中获取该操作的 URL。

```
<account>
    <account_number>12345</account_number>
    <balance currency="usd">-25.00</balance>
    <link rel="deposit" href="https://bank.example.com/account/12345/deposit" />
</account>
```

除了 HATEOAS 之外，还有一种称为超文本应用程序语言（简称 HAL）的替代实现，它比基本的 HATEOAS 具有更多的功能。

使用 HAL，您还可以定义参数化链接、嵌入式资源和文档关系（称为 curies）。您可以在此处找到规范。http: [//stateless.co/hal_specification.html](http://stateless.co/hal_specification.html)

如果您想在 API 响应中链接不同的 API 端点或资源位置，则应使用此标准。

## STRIDE 威胁建模

STRIDE 是一种威胁组模型，有助于识别对任何应用程序、组件或基础设施的安全威胁。

该缩写代表：

- **欺骗**
- **篡改**
- **否认**
- **信息**披露
- **拒绝**服务
- 特权**提升**

[AOE 正在使用特权提升卡牌游戏](https://social.technet.microsoft.com/wiki/contents/articles/285.elevation-of-privilege-the-game.aspx)在协作会议中应用威胁模型，这有助于激发想象力并使威胁变得更加切实。

## GitFlow

从那时起，关于团队应该使用的版本控制策略的讨论就一直存在。

在 AOE，我们也有过这样的经验：当新团队开始使用阻塞或长寿命功能分支（所有评审意见完成后才进行合并）时，这会对团队绩效产生负面影响。

我们建议使用基于主干的开发和短期（<1 天）功能分支，因为事实证明这最能支持持续集成和团队协作。但是，我们确实接受团队使用 GitFlow 的选择；我们只是一开始并不鼓励他们这样做。

参见：

- [基于主干的开发](https://trunkbaseddevelopment.com/)
- [一次提交，一次变更](https://medium.com/@fagnerbrack/one-commit-one-change-3d10b10cebbf)
- [功能分支](https://martinfowler.com/bliki/FeatureBranch.html)
- [组织反模式：构建功能分支](https://www.continuousdeliveryconsulting.com/blog/organisation-antipattern-build-feature-branching/)

## 微型筒仓

领域驱动设计 (DDD) 的核心概念是将问题领域提炼为不同的有界上下文，并指派专门的团队负责这些上下文。微服务通常用于在软件应用程序中实现这些有界上下文。根据康威定律，团队之间的沟通模式将决定这些微服务的设计和交互方式。

团队自主性对于实现真正独立的微服务架构、推动创新和敏捷性至关重要。然而，完全自主性可能导致微孤岛的形成：孤立的团队独立工作，通常会导致实施不一致、沟通不畅、隐藏依赖关系和冗余。

### 缓解策略

- **战略领域驱动设计**：确保有界上下文及其相互关系在组织上（团队结构）和技术上（接口）都定义明确。
- **跨团队沟通**：促进定期会议，使用协作工具，并定期举行跨团队研讨会，以改善信息共享和协调。
- **领域专家和协调角色**：任命系统架构师、领域专家和集成负责人来监督跨团队协调并保持与整体项目目标的一致性。

重要的是在自主性和协调性之间取得平衡，以便从独立性中受益，同时确保整个组织的凝聚力和高效合作。