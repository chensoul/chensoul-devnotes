import{_ as i,c as a,a0 as o,o as r}from"./chunks/framework.DHkrr0_B.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm.md","filePath":"java/jvm.md"}'),t={name:"java/jvm.md"};function e(n,l,s,g,c,u){return r(),a("div",null,l[0]||(l[0]=[o('<h2 id="常见面试问题" tabindex="-1">常见面试问题 <a class="header-anchor" href="#常见面试问题" aria-label="Permalink to &quot;常见面试问题&quot;">​</a></h2><p>jdk、jre 及 jvm 关系</p><p>类加载机制是什么</p><p>类加载器有哪些</p><p>双亲委派机制</p><p>如何打破双亲委派</p><p>运行时数据</p><p>栈帧结构</p><p>堆为什么要分代设计</p><p>为什么 Eden:s1:s0是8:1:1</p><p>对象的创建过程</p><p>方法区、元数据和永久代有什么关系</p><p>垃圾回收算法</p><p>垃圾收集器</p><h2 id="jdk、jre-及-jvm-关系" tabindex="-1">jdk、jre 及 jvm 关系 <a class="header-anchor" href="#jdk、jre-及-jvm-关系" aria-label="Permalink to &quot;jdk、jre 及 jvm 关系&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/20181102183439614.png" alt="img"></p><ol><li><strong>JVM（Java Virtual Machine）</strong>： <ul><li>JVM是Java虚拟机，它是一个抽象的计算机，能够运行Java字节码（.class文件）。JVM为Java程序提供了一个与平台无关的执行环境，使得Java程序能够在任何安装了相应JVM的设备上运行。</li><li>JVM的主要任务是装载字节码到其内部数据结构中，解释字节码指令，以及执行这些指令。</li></ul></li><li><strong>JRE（Java Runtime Environment）</strong>： <ul><li>JRE是Java运行时环境，它包含了运行Java程序所必需的组件，包括JVM以及Java核心类库和支持文件。JRE确保了Java程序能够在特定的操作系统上运行。</li><li>JRE不包含开发工具，如编译器（javac），因此它只适用于运行Java程序，不适用于开发。</li></ul></li><li><strong>JDK（Java Development Kit）</strong>： <ul><li>JDK是Java开发工具包，它包含了JRE的所有内容，并且额外提供了编译器（javac）、调试工具（jdb）、性能分析工具（jconsole）等开发工具。</li><li>JDK是为Java开发者设计的，它允许开发者编写、编译、调试和打包Java应用程序。</li></ul></li></ol><p><strong>它们之间的关系</strong>：</p><ul><li>JDK包含了JRE，因为要开发Java程序，你需要运行时环境来测试和运行这些程序。</li><li>JRE包含了JVM，因为运行Java程序需要JVM来执行字节码。</li><li>简而言之，JDK是用于开发Java程序的，它包含了JRE，而JRE是用于运行Java程序的，它包含了JVM。</li></ul><h2 id="类加载机制是什么" tabindex="-1">类加载机制是什么 <a class="header-anchor" href="#类加载机制是什么" aria-label="Permalink to &quot;类加载机制是什么&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1e9bcfc50a59a7119fbb48bed3a8d600.webp" alt="img"></p><p>Java的类加载机制是指在运行时动态加载.class文件的机制。这个过程主要涉及三个部分：类加载器（ClassLoader）、链接器（Linker）和执行引擎（Execution Engine）。类加载机制包括加载、链接和初始化三个阶段。下面详细解释每个阶段：</p><ol><li><strong>加载（Loading）</strong>： <ul><li>这个阶段是类加载过程的第一个阶段。在这个阶段，类加载器（ClassLoader）根据给定的全限定名（如<code>com.example.MyClass</code> ）来加载类的.class文件。</li><li>加载过程涉及到读取.class文件，并且将这个类的二进制数据读入到JVM中</li><li>在内存中创建一个java.lang.Class对象，这个对象代表了这个类的结构。</li></ul></li><li><strong>链接（Linking）</strong>： <ul><li><strong>验证</strong>：确保加载的类信息符合JVM规范，没有安全问题。</li><li><strong>准备</strong>：为类的静态变量分配内存，并设置默认初始值。</li><li><strong>解析</strong>：将类、接口、字段和方法的符号引用转换为直接引用，即实际内存地址的引用。</li></ul></li><li><strong>初始化（Initialization）</strong>： <ul><li>在这个阶段，JVM执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，这包括了执行静态变量的赋值操作以及静态代码块中的指令。</li><li>这个阶段是类加载过程的最后一个阶段，直到一个类被初始化，这个类的方法才可以被调用。</li></ul></li></ol><h2 id="类加载器有哪些" tabindex="-1">类加载器有哪些 <a class="header-anchor" href="#类加载器有哪些" aria-label="Permalink to &quot;类加载器有哪些&quot;">​</a></h2><p><img src="https://a.perfma.net/img/281415" alt="img"></p><ol><li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：负责加载JVM基础核心类库，如<code>java.lang.*</code>包中的类。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载Java扩展库中的类，例如<code>jre/lib/ext</code>目录下的类或由系统属性 <code>java.ext.dirs</code>指定位置的类。</li><li><strong>系统（应用）类加载器（System ClassLoader）</strong>：负责加载系统类路径<code>java.class.path</code>上指定的类库，通常是你的应用类和第三方库。</li><li><strong>自定义类加载器（Custom ClassLoader）</strong>：Java允许用户创建自己的类加载器，通过继承<code>java.lang.ClassLoader</code>类的方式实现。</li></ol><h2 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h2><p>Java类加载器的双亲委派模型，即子类加载器在尝试加载类之前，会先委托给父类加载器进行加载。</p><p><strong>优点</strong>：</p><ul><li><strong>避免类的多次加载</strong>：如果父类加载器已经加载了该类，就不需要子类加载器再加载，这样保证了Java程序中同一个类只会被加载一次。</li><li><strong>提供了一种安全机制</strong>：可以防止核心库的类被随意篡改。</li></ul><h2 id="如何打破双亲委派" tabindex="-1">如何打破双亲委派 <a class="header-anchor" href="#如何打破双亲委派" aria-label="Permalink to &quot;如何打破双亲委派&quot;">​</a></h2><p>1、重写 ClassLoader 的<code>loadClass</code>方法。在自定义类加载器中，你可以直接重写<code>loadClass</code>方法，而不是委派给父类加载器。</p><p>2、使用 SPI。线程上下文类加载器 ThreadContextClassLoader 可能会加载父类加载器无法识别的类。</p><p>3、OSGI。OSGi通过模块化的方式，允许模块间进行精细的类依赖控制，打破了传统的双亲委派模型</p><h2 id="运行时数据" tabindex="-1">运行时数据 <a class="header-anchor" href="#运行时数据" aria-label="Permalink to &quot;运行时数据&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8b620cc2d2c8ff96fc801e6981587206.png" alt="img"></p><p>VM运行时数据区是Java虚拟机在执行Java程序过程中管理的内存区域，它们被划分为不同的部分，每个部分都有特定的用途和生命周期。</p><ol><li><strong>程序计数器（Program Counter Register）</strong>： <ul><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</li><li>它用于存储指向下一条指令的地址，由执行引擎读取下一条指令。</li><li>程序计数器是线程私有的，每个线程都有自己的程序计数器，且程序计数器是唯一一个在Java虚拟机规范中没有规定任何 <code>OutOfMemoryError</code>情况的区域。</li></ul></li><li><strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>： <ul><li>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。</li><li>栈帧中存储着局部变量表、操作数栈、动态链接和方法返回地址等信息。</li><li>Java虚拟机栈的生命周期与线程一致，且每个线程都有自己的栈，栈中数据都是以栈帧的格式存在。</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong>： <ul><li>本地方法栈与虚拟机栈相似，它为native方法提供服务。</li><li>用于支持本地方法的执行，管理本地方法的调用和执行过程。</li></ul></li><li><strong>堆（Heap）</strong>： <ul><li>堆是所有线程共享的内存区域，用于存放所有类实例和数组对象。</li><li>堆是垃圾收集器工作的主要区域，可以是固定大小的，也可以根据计算的需要进行扩展。</li><li>堆内存里的对象不会被显式的回收，而是由垃圾回收器回收。</li></ul></li><li><strong>方法区（Method Area）</strong>： <ul><li>方法区是线程共享的区域，用于存储已被JVM加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据。</li><li>它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通函数的字节码内容。</li><li>在JDK 8中，方法区的实现被改为元空间（Metaspace），不再是JVM内存的一部分，而是通过本地内存（Native Memory）来实现的。</li></ul></li><li><strong>运行时常量池</strong>： <ul><li>运行时常量池是方法区中的一个重要部分，它主要负责存储字节码文件中的常量池内容。</li><li>包括了若干不同的常量，比如从编译期可知的数值字面量到运行时才能解析获得的方法或字段引用等等</li></ul></li></ol><h2 id="栈帧结构" tabindex="-1">栈帧结构 <a class="header-anchor" href="#栈帧结构" aria-label="Permalink to &quot;栈帧结构&quot;">​</a></h2><p><a href="https://cloud.tencent.com/developer/article/2145582" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/2145582</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8752617/48bdb73c8ddccb7237d4344c15ff3e4e.png" alt="img"></p><p>栈帧（Stack Frame）是Java虚拟机栈（Java Virtual Machine Stack）中的基本数据结构，它描述了每个方法执行时的状态。每当一个方法被调用，Java虚拟机就会创建一个新的栈帧，用于存储局部变量、操作数栈、动态链接信息和方法出口等。一个栈帧对应一个方法的调用。</p><ol><li><strong>局部变量表（Local Variables）</strong>： <ul><li>存放方法的局部变量，包括基本数据类型、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。</li><li>局部变量表中存储数据的最小单位为变量槽（Slot）。</li><li>64位长度的long和double类型的数据会占用2个变量槽，其余的数据类型只占用1个Slot。</li></ul></li><li><strong>操作数栈（Operand Stack）</strong>（或表达式栈）： <ul><li>后进先出（LIFO）的栈结构，用于存储操作数，即方法执行过程中的中间数据。</li><li>字节码指令会从局部变量表或另一个栈帧中获取数据，然后压入操作数栈，并在执行过程中从栈中弹出数据进行计算。</li></ul></li><li><strong>动态链接（Dynamic Linking）</strong>： <ul><li>用于支持方法调用过程中的动态链接，即动态确定调用的方法的地址。</li><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，以支持方法调用中的动态链接。</li></ul></li><li><strong>方法返回地址（Return Address）</strong>： <ul><li>存储方法执行完毕后的返回位置，即方法正常退出或异常退出时的地址。</li><li>对于非<code>void</code>返回的方法，这里还会存储方法的返回值。</li></ul></li><li><strong>附加信息</strong>： <ul><li>可能包括对齐填充，以及与性能监控、调试相关的信息。</li></ul></li></ol><h2 id="堆为什么要分代设计" tabindex="-1">堆为什么要分代设计 <a class="header-anchor" href="#堆为什么要分代设计" aria-label="Permalink to &quot;堆为什么要分代设计&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/c4a0bd9eab6c49faaebd11866bd6c0ac.png" alt="img"></p><p>JVM的分代垃圾回收策略是基于对象生命周期的不同而设计的。这种设计的主要优点包括：</p><ol><li><p><strong>提高垃圾回收效率</strong>：</p><ul><li><p>大多数对象的生命周期较短，可以在新生代中频繁地进行垃圾回收（Minor GC），而不必扫描整个堆，这大大提高了垃圾回收的效率。</p></li><li><p>老年代中的对象生命周期较长，老年代的垃圾回收（Major GC 或 Full GC）通常比新生代的垃圾回收要慢得多，因为需要扫描和处理更多的对象。通过分代，可以减少触发全局垃圾回收的次数。</p></li></ul></li><li><p><strong>使用不同垃圾回收算法，优化内存使用</strong>：</p><ul><li>不同的内存区域可以根据存储对象的特点采用最适合的垃圾回收算法。例如，新生代适合使用复制算法，因为它们需要频繁地回收对象，而老年代则适合使用标记-清除或标记-整理算法，因为它们的对象生命周期长，回收频率低。</li></ul></li></ol><h2 id="eden区与survivor区-s0和s1-的比例为什么为8-1-1" tabindex="-1">Eden区与Survivor区（S0和S1）的比例为什么为8:1:1 <a class="header-anchor" href="#eden区与survivor区-s0和s1-的比例为什么为8-1-1" aria-label="Permalink to &quot;Eden区与Survivor区（S0和S1）的比例为什么为8:1:1&quot;">​</a></h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91OTlKaWJpY3dsdHZIdFVwMWdibXBiMzNERWljR3BzcmhtWDVydE56RTFFTHl6MTNFU3VtZEJPSFFIM0RBMmNpYUFQYnFkVVBqeWVXakhsbnVQZ0doazY2YXcvNjQw?x-oss-process=image/format,png" alt="img"></p><ol><li><strong>提高垃圾回收效率</strong>：根据统计，大约98%的对象在新生代就会被回收，这意味着只有大约2%的对象会从新生代存活到老年代。8:1:1 的比例，可以确保在Minor GC时，只有少量存活的对象需要被复制到Survivor区，从而提高内存利用率和垃圾回收效率。</li><li><strong>避免内存浪费</strong>：S0和S1设置为1:1，可以保证在任何时候都有一个Survivor区是空的，从而为复制存活对象提供空间，同时避免了内存的浪费。</li><li><strong>减少内存碎片</strong>：通过保持Survivor区相对较小，可以减少因复制存活对象而产生的内存碎片，因为每次Minor GC后，至少有一个Survivor区是完全空闲的，从而可以避免碎片化的问题。</li></ol><h2 id="对象的创建过程" tabindex="-1">对象的创建过程 <a class="header-anchor" href="#对象的创建过程" aria-label="Permalink to &quot;对象的创建过程&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/20200322130254447.png" alt="img"></p><ol><li><p><strong>类加载检查</strong>：</p><ul><li>当程序创建一个新的对象时，JVM首先检查这个对象的类是否已经被加载过。如果类还没有被加载，JVM会通过类加载器进行加载。</li></ul></li><li><p><strong>分配内存</strong>：</p><ul><li><p>如果类已经被加载，JVM会在堆内存中为新对象分配内存。对于对象内存的分配通常有两种方式：指针碰撞（Bump the Pointer）和空闲列表（Free List）。</p><ul><li>在使用Serial、ParNew等带有压缩整理功能的垃圾收集器时，通常采用指针碰撞方式，因为这些收集器在回收内存后会整理内存，使得内存是连续的。</li><li>如果垃圾收集器不带有压缩整理功能，如CMS收集器，通常采用空闲列表方式。</li></ul></li><li><p>在多线程环境中，为了避免多个线程同时为对象分配内存而导致的冲突，JVM采用CAS（Compare-And-Swap）操作来保证内存分配的原子性。</p></li><li><p>另外，JVM还可能使用TLAB（Thread Local Allocation Buffer）来减少多线程同时分配内存时的锁竞争。</p></li></ul></li><li><p><strong>初始化为零值</strong>：</p><ul><li>分配内存后，JVM会将分配到的内存空间初始化为零值（不包括对象头信息）。</li></ul></li><li><p><strong>设置对象头：</strong></p><ul><li>包括对象的哈希码、GC分代年龄、锁信息等。</li></ul></li><li><p><strong>执行构造函数</strong>：</p><ul><li>初始化内存后，JVM会调用对象的构造函数（<code>&lt;init&gt;</code>方法），对对象进行初始化设置。</li></ul></li></ol><h2 id="方法区、元数据和永久代有什么关系" tabindex="-1">方法区、元数据和永久代有什么关系 <a class="header-anchor" href="#方法区、元数据和永久代有什么关系" aria-label="Permalink to &quot;方法区、元数据和永久代有什么关系&quot;">​</a></h2><p><img src="https://img-blog.csdnimg.cn/f1c5c8c98043442ebf65245d80c18715.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210228122152194.png" alt="img"></p><ul><li>方法区是JVM规范中定义的一个内存区域，用于存储类的元数据等信息。</li><li>永久代和元空间都是方法区的具体实现，但它们存在于不同的Java版本中： <ul><li>永久代：Java 8之前的HotSpot虚拟机实现。</li><li>元空间：Java 8及以后版本的HotSpot虚拟机实现。</li></ul></li><li>主要区别在于： <ul><li>位置：永久代在JVM堆内存中，而元空间在本地内存中。</li><li>大小限制：永久代有固定的大小限制，元空间的大小受本地内存限制。</li><li>内存溢出：永久代满了会抛出 <code>OutOfMemoryError: PermGen space</code>，而元空间满了会抛出 <code>OutOfMemoryError: Metaspace</code></li></ul></li></ul><h2 id="垃圾回收算法" tabindex="-1">垃圾回收算法 <a class="header-anchor" href="#垃圾回收算法" aria-label="Permalink to &quot;垃圾回收算法&quot;">​</a></h2><ol><li><strong>标记-清除（Mark-Sweep）算法</strong>： <ul><li>这是最基础的垃圾回收算法。它分为两个阶段：标记阶段和清除阶段。</li><li>在标记阶段，垃圾回收器遍历所有根对象，并标记所有从根对象可达的对象。</li><li>在清除阶段，未被标记的对象被认为是垃圾，垃圾回收器将它们回收。</li><li>缺点是会产生内存碎片。</li></ul></li><li><strong>标记-整理（Mark-Compact）算法</strong>： <ul><li>为了解决标记-清除算法中的内存碎片问题，标记-整理算法在标记阶段之后会将所有存活的对象向一端移动，然后清理边界以外的内存。</li><li>这样可以减少内存碎片，但移动对象可能会增加算法的开销。</li></ul></li><li><strong>复制（Copying）算法</strong>： <ul><li>该算法将内存分为两个或多个相同的半区，每次只使用其中一个半区。</li><li>当一个半区内存不足时，垃圾回收器会复制仍然存活的对象到另一个半区，并清空正在使用的半区。</li><li>适用于新生代，因为新生代中的对象大多是“朝生夕死”，所以复制的成本相对较低。</li></ul></li><li><strong>增量收集（Incremental Collection）算法</strong>： <ul><li>为了减少垃圾回收的停顿时间，增量收集算法将垃圾回收过程分为多个小步骤，分步骤执行，以减少每次停顿的时间。</li></ul></li><li><strong>分代收集（Generational Collection）算法</strong>： <ul><li>基于对象生命周期的不同，将堆内存分为新生代和老年代。</li><li>新生代使用复制算法，老年代使用标记-清除或标记-整理算法。</li><li>这种算法认为大多数对象在新生代就会被回收，只有少量对象会存活到老年代。</li></ul></li><li><strong>并行垃圾回收（Parallel GC）</strong>： <ul><li>并行垃圾回收使用多线程同时进行垃圾回收，以提高垃圾回收的效率。</li></ul></li><li><strong>并发标记-清除（Concurrent Mark-Sweep, CMS）算法</strong>： <ul><li>CMS算法尝试最小化垃圾回收的停顿时间，通过并发执行标记和清除阶段来实现。</li><li>它分为四个步骤：初始标记、并发标记、最终标记和并发清除。</li></ul></li><li><strong>G1（Garbage-First）算法</strong>： <ul><li>G1算法是JVM在Java 7中引入的一种服务器端垃圾回收器，旨在替换CMS算法。</li><li>它将堆内存划分为多个区域，并优先回收垃圾最多的区域。</li><li>G1算法可以更精确地控制停顿时间，并且可以处理更大的堆内存。</li></ul></li><li><strong>ZGC（Z Garbage Collector）和Shenandoah GC</strong>： <ul><li>这些是Java 11中引入的新型垃圾回收器，它们支持并发处理，并且旨在在处理大堆内存时实现可预测的低延迟。</li></ul></li></ol><h2 id="垃圾收集器" tabindex="-1">垃圾收集器 <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to &quot;垃圾收集器&quot;">​</a></h2><ol><li><strong>Serial Garbage Collector</strong>： <ul><li>单线程的垃圾收集器，适用于小型应用和客户端应用。</li><li>在进行垃圾回收时，会暂停所有用户线程（Stop-The-World事件）。</li></ul></li><li><strong>Parallel Garbage Collector</strong>（也称为Throughput Collector）： <ul><li>多线程的垃圾收集器，注重吞吐量，适合多处理器机器。</li><li>在垃圾回收期间，会暂停所有用户线程，并使用多个线程进行垃圾回收，以提高效率。</li></ul></li><li><strong>CMS (Concurrent Mark-Sweep) Collector</strong>： <ul><li>以最小化停顿时间为目标的垃圾收集器，适用于交互式应用。</li><li>在标记和清除阶段与用户线程并发执行，但仍然需要短暂的停顿。</li></ul></li><li><strong>G1 (Garbage-First) Garbage Collector</strong>： <ul><li>服务器端垃圾收集器，旨在取代CMS收集器。</li><li>将堆划分为多个区域，并优先回收垃圾最多的区域。</li><li>可以更精确地控制停顿时间，并能处理更大的堆内存。</li></ul></li><li><strong>Garbage-First (G1) New Generation Garbage Collector</strong>： <ul><li>G1收集器的变种，专门用于处理新生代。</li></ul></li><li><strong>Shenandoah Garbage Collector</strong>： <ul><li>低延迟垃圾收集器，与用户线程并发执行。</li><li>适合需要连续吞吐量和低延迟的应用。</li></ul></li><li><strong>ZGC (Z Garbage Collector)</strong>： <ul><li>可扩展、低延迟的垃圾收集器。</li><li>支持大堆内存，并尽量减少停顿时间。</li></ul></li><li><strong>Epsilon Garbage Collector</strong>： <ul><li>一个基本上不执行垃圾回收工作的垃圾收集器，用于性能测试。</li></ul></li><li><strong>Parallel Old Garbage Collector</strong>： <ul><li>是Parallel GC的老年版本，使用多线程进行垃圾回收，适合老年代。</li></ul></li><li><strong>ConcMarkSweepGC</strong>： <ul><li>JDK 9中引入的CMS收集器的替代品，提供了更好的性能和更低的延迟。</li></ul></li></ol>',61)]))}const h=i(t,[["render",e]]);export{d as __pageData,h as default};
